<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何在代码中减少if else语句的使用]]></title>
      <url>%2F2016%2F09%2F21%2Freduce-if-else%2F</url>
      <content type="text"><![CDATA[前言代码中嵌套的if/else结构往往导致代码不美观，也不易于理解。面向过程的开发中代码有大量的if else，在java中可以用一些设计模式替换掉这些逻辑，那么在js中是否也有类似的方法用来尽可能减少代码中的if/else嵌套呢？有人认为：if else多就多呗，只要可读性强，维护起来方便。jQuery.fn.init里就是一堆if else判断，难道要质疑jQuery作者的水平了？ 并不是说if else多就不好，关键是看用的地方，jQuery.fn.init里除了if else判断简洁点，难道要改成switch？就算用工厂模式，还不是得做大量的if判断。 常用方法代码整洁强迫症患者必须要来个抛砖引玉： 1. 使用||或12345if(a为真)&#123; a=a&#125;else&#123; a=b&#125; 可写成：a = a || b 2. 使用三元表达式12345if(a==b)&#123; a=c&#125;else&#123; a=d&#125; 可写成：a = (a==b) ? c : d 3. 结合数组后台接口通常会返回这种数据：fruit: 0 // 0=苹果，1=梨子，2=桔子，3=柠檬，4=芒果…这时写if…else是最痛苦的。从冲哥那偷来个方法：12var _f = [&apos;苹果&apos;,&apos;梨子&apos;,&apos;桔子&apos;,&apos;柠檬&apos;,&apos;芒果&apos;];shuiguo = _f[fruit]; 建议 第一步：优化if逻辑人们考虑的东西到时候，都会把最可能发生的情况先做好准备。优化if逻辑的时候也可以这样想：把最可能出现的条件放在前面，把最不可能出现的条件放在后面，这样程序执行时总会按照带啊名的先后顺序逐一检测所有的条件，知道发现匹配的条件才会停止继续检测。 if的优化目标：最小化找到分支之前所判断条件体的数量。if优化的方法：将最常见的条件放在首位。1234567if(i &lt; 5) &#123; // 执行一些代码&#125; else if (i &gt; 5 &amp;&amp; i &lt; 10) &#123; // 执行一些代码&#125; else &#123; // 执行一些代码&#125; 例如上面这个例子，只有在i值经常出现小于5的时候是最优化的。如果i值经常大于或者等于10的话，那么在进入正确的分支之前，就必须两次运算条件体，导致表达式的平均运算时间增加。if中的条件体应该总是按照从最大概率到最小概率排列，以保证理论速度最快。 第二步：尽量少使用else如果在函数中，可以使用 if + return，先判断错误条件，然后立马结束函数，防止进入 else 分支。 举个简单的例子，后端返回数据，前端根据状态进行不同操作123456789$.ajax().done(function (res) &#123; if (res.state === &apos;SUCCESS&apos;) &#123; //TODO &#125; else if (res.state === &apos;FAIL&apos;) &#123; //TODO &#125; else &#123; //TODO &#125;&#125;); 这里用if else不挺好的么，有啥问题么？不过我个人倾向于switch。 解决方法 switch/case switch和if else在性能上是没有什么区别的，主要还是根据需求进行分析和选择。 如果条件较小的话选用if else比较合适。相反，条件数量较大的话，就建议选用switch。一般来说，if else适用于两个离散的值或者不同的值域。如果判断多个离散值，使用switch更加合适。 在大多数的情况下switch比if else运行的更加快。 在大多数情况下，switch的性能不会比if else低。switch的确在实质上跟if else if 完全一样的效果，不过在很多情况下，使用switch要比if else方便不少 比如经典的值等分支，匹配一些状态常量的时候，比if else结构方便许多，不用反复写xx == yy123456789101112$.ajax().done(function (res) &#123; switch (res.state) &#123; case &apos;SUCCESS&apos;: //TODO break; case &apos;FAIL&apos;: //TODO break; default : //TODO &#125;&#125;); 注意：千万不要忘记在每一个case语句后面放一个break语句。也可以放一个return或者throw。case语句匹配expression是用===而不是==。 2.hash 表1234567if (key == &quot;Apple&quot;) &#123; val = &quot;Jobs&quot;;&#125; else if (key == &quot;microsoft&quot;)&#123; val = &quot;Gates&quot;;&#125; else if (key == &quot;Google&quot;)&#123; val = &quot;Larry&quot;;&#125; 这个也可以用 switch case 解决，不过推荐的方法是 hash 表：12var ceos = &#123;&quot;Apple&quot;:&quot;Jobs&quot;, &quot;microsoft&quot;:&quot;Gates&quot;, &quot;Google&quot;:&quot;Larry&quot;&#125;;val = ceos[key]; 3.重构，用 OO 里面的继承或者组合 1.如果是狗，则汪汪2.如果是猫，则喵喵3.如果是羊，则咩咩4.如果是鸭，则嘎嘎 可以重构一下，改成 OO。 定义类： 动物（或者接口） 定义方法：叫定义子类：狗、猫、羊、鸭 重写方法 —- 叫 也就是说将同的判断按照功能，写成函数，这样也便于阅读比如我有一个方法根据类型获取名称，用if else会这样123456789function getName(type) &#123; if (type === &apos;monkey&apos;) &#123; return &apos;monkey name&apos;; &#125; else if (type === &apos;cat&apos;) &#123; return &apos;cat name&apos;; &#125; else &#123; return &apos;dog name&apos;; &#125;&#125; 如果写成函数，改成下面的会更好12345678function getName(type) &#123; var data = &#123; monkey: &apos;monkey name&apos;, cat: &apos;cat name&apos;, dog: &apos;dog name&apos; &#125; return data[type] ? data[type] : data[&apos;dog&apos;];&#125; 硬要把设计模式添加到JS里不是不可以，但是要看情况。生搬硬套过来的东西然并卵啊。 写代码记住三个字即可，短简易。代码短，读起来简单，维护容易，如果在性能和代码长度上二选一，我肯定选代码短，性能不行，加台服务器就是了。而冗长的代码并不是加个程序员就能搞定的。 保持着这个心态写代码，写出的东西离设计模式也不会差太多了。 多说一句：存在必有其价值，不能说if else多了就不好，凡事无绝对，适合A的未必就适合B，每个东西都有其实现的场景。同理改写设计模式未必就是最棒的，听起来高大上点而已。 来源：http://www.xuanfengge.com/how-to-reduce-the-use-of-if-else-statements.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS实现背景透明，文字不透明(兼容所有浏览器)]]></title>
      <url>%2F2016%2F08%2F11%2Fcss-opacity%2F</url>
      <content type="text"><![CDATA[我们平时所说的调整透明度，其实在样式中是调整不透明度，如下图所示例：打开ps，在图层面板上，可以看到设置图层整理不透明度的菜单，从 0% （完全透明）到 100%（完全不透明）。实现透明的css方法通常有以下3种方式，以下是不透明度都为80%的写法 css3的opacity:x，x 的取值从 0 到 1，如opacity: 0.8css3的rgba(red, green, blue, alpha)，alpha的取值从 0 到 1，如rgba(255,255,255,0.8)IE专属滤镜 filter:Alpha(opacity=x)，x 的取值从 0 到 100，如filter:Alpha(opacity=80)css3的opacity 兼容性：IE6、7、8不支持，IE9及以上版本和标准浏览器都支持 使用说明：设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;opacity&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000; opacity: 0.2;&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 使用opacity后整个模块都透明了，展现如下：那么使用opacity实现《背景透明，文字不透明》是不可取的。css3的rgba兼容性：IE6、7、8不支持，IE9及以上版本和标准浏览器都支持使用说明：设置颜色的不透明度，一般用于调整background-color、color、box-shadow等的不透明度。123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;css3的rgba&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000;/* IE6和部分IE7内核的浏览器(如QQ浏览器)下颜色被覆盖 */ background-color:rgba(0,0,0,0.2); /* IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂，但解析为透明 */&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 在background-color中使用rgba，标准浏览器中，背景透明，文字不透明，展现如下：很奇葩的是，IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂rgba，解析后颜色为透明，其实应该是null那么使用opacity实现背景透明，文字不透明是可取的。 IE专属滤镜 filter:Alpha(opacity=x) 使用说明：IE浏览器专属，问题多多，本文以设置背景透明为例子，如下： 1、仅支持IE6、7、8、9，在IE10版本被废除2、在IE6、7中，需要激活IE的haslayout属性(如：zoom:1或者overflow:hidden)，让它读懂filter:Alpha3、在IE6、7、8中，设置了filter:Alpha的元素，父元素设置position:static(默认属性)，其子元素为相对定位，可让子元素不透明12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;opacity&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background: #000000; filter:Alpha(opacity=50);/* 只支持IE6、7、8、9 */ position:static; /* IE6、7、8只能设置position:static(默认属性) ，否则会导致子元素继承Alpha值 */ *zoom:1; /* 激活IE6、7的haslayout属性，让它读懂Alpha */&#125;.demo p&#123; color: #FFFFFF; position: relative;/* 设置子元素为相对定位，可让子元素不继承Alpha值，保证字体颜色不透明 */&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt; &lt;p&gt;背景透明，文字不透明&lt;/p&gt;&lt;/div&gt; 全兼容的方案 上以上3点分析可知，设置透明背景文字不透明，可采用的属性有rgba和IE的专属滤镜filter:Alpha，其兼容性如下图所示：针对IE6、7、8浏览器，我们可以采用fiter:Alpha，针对标准浏览器我们采用rgba，那么问题来了，IE9浏览器2个属性都支持，一起使用会重复降低不透明度… 那么，如何只对IE6、7、8使用fiter:Alpha如何实现呢？123/* 只支持IE6、7、8 */@media \0screen\,screen\9 &#123;...&#125; ok，所有问题都解决了，全部代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;背景透明，文字不透明&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color: rgba(0,0,0,0.5);/* IE9、标准浏览器、IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂 */&#125;.demo p&#123; color: #FFFFFF;&#125;@media \0screen\,screen\9 &#123;/* 只支持IE6、7、8 */ .demo&#123; background-color:#000000; filter:Alpha(opacity=50); position:static; /* IE6、7、8只能设置position:static(默认属性) ，否则会导致子元素继承Alpha值 */ *zoom:1; /* 激活IE6、7的haslayout属性，让它读懂Alpha */ &#125; .demo p&#123; position: relative;/* 设置子元素为相对定位，可让子元素不继承Alpha值 */ &#125; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt; &lt;p&gt;背景透明，文字不透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 我们看到这个可能会觉得很复杂，为什么不直接用两个DIV放在同一个位置就行了，一个不透明DIV，一个文字DIV，很简单的解决问题，这也是好个方法，但是需要写绝对定位或负margin，并出现空内容的DIV，而且这是这种方法在有些场景下也会显得复杂，如下示例，鼠标经过商标后展现展现透明的提示文案，就需要控制2个DIV啦~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[鼠标显示一个层的同时隐藏其他层]]></title>
      <url>%2F2016%2F06%2F22%2Fhtml-displayhidden%2F</url>
      <content type="text"><![CDATA[代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css" media="screen"&gt; *&#123;padding:0;margin: 0;&#125; p&#123; width:200px; height:200px; background: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="id1" style="display:none;" href="#" onMouseOver="show(0)"&gt; &lt;div&gt;1111&lt;/div&gt;&lt;/a&gt;&lt;div id="child1" style="display:block;"&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;a id="id2" href="#" onMouseOver="show(1)"&gt; &lt;div&gt;2222&lt;/div&gt;&lt;/a&gt;&lt;div id="child2" style="display:none;"&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;a id="id3" href="#" onMouseOver="show(2)"&gt; &lt;div&gt;3333&lt;/div&gt;&lt;/a&gt;&lt;div id="child3" style="display:none;"&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;script language="javascript"&gt; function show(id)&#123; var aId= ["id1","id2","id3"]; var div=["child1","child2","child3"]; for(i=0;i&lt;3;i++)&#123; document.getElementById(div[i]).style.display=(i==id?"block":"none"); document.getElementById(aId[i]).style.display=(i==id?"none":"block"); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css" media="screen"&gt; *&#123;padding:0;margin: 0;&#125; li&#123;list-style:none;&#125; li&#123; width:200px; &#125; li p&#123; width:200px; &#125; li .content&#123; display: none; height:200px; width:200px; background:red; &#125; .active&#123; &#125; .active .title&#123; display:none; &#125; .active .content&#123; display:block; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="container"&gt; &lt;li class="active"&gt; &lt;p class="title"&gt;111111111&lt;/p&gt; &lt;div class="content"&gt; 1的内容&lt;br /&gt; 1的内容&lt;br /&gt; 1的内容 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;p class="title"&gt;222222222&lt;/p&gt; &lt;div class="content"&gt; 2的内容&lt;br /&gt; 2的内容&lt;br /&gt; 2的内容 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;p class="title"&gt;333333333&lt;/p&gt; &lt;div class="content"&gt; 3的内容&lt;br /&gt; 3的内容&lt;br /&gt; 3的内容 &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $('.container').on('mouseenter', 'li', function(event) &#123; event.preventDefault(); /* Act on the event */ $(this).addClass('active').siblings('li').removeClass('active');&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一切都在代码中，无以言表~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用纯粹的CSS3替代小图标---向右箭头]]></title>
      <url>%2F2016%2F05%2F12%2Fcss-arrow%2F</url>
      <content type="text"><![CDATA[1、向右的箭头&gt; . 看到很多网站里面向右的箭头都是图片代替的，但是为了网站的性能，我们一般的原则是能够避免使用图片的尽量不用图片比如看下携程个人中心首页面，向右的箭头 其实现思路是这样的：定义一个正方形盒子，盒子边框定义1px的上边框和右边框，然后对盒子旋转45度即可。 代码如下： 1&lt;i class="arrow"&gt;&lt;/i&gt; 123456789.arrow&#123; display: inline-block; width: 7px; height: 7px; border: solid #999; border-width: 1px 1px 0 0; -webkit-transform:rotate(-45deg); transform:rotate(-45deg);&#125; 嘘…我们能不能直接使用符号“ &gt; “这个呢。来来来，看淘宝网审查元素之后发现它是这样实现的。1&lt;i class="tb-icon service-arrow"&gt;➤&lt;/i&gt; 123456789.tb-icon&#123; font-family: iconfont!important; font-size: 14px; font-style: normal; display: inline-block; text-decoration: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 看到没，淘宝都这样做，我们何不借鉴下呢。 不过它在添加字符的时候额外修饰了一番。使用字体抗锯齿属性:-webkit-font-smoothing 对字体进行抗锯齿渲染可以使字体看起来会更清晰舒服。在图标字体成为一种趋势的今天，抗锯齿渲染使用也越来越多。 font-smoothing是非标准的CSS定义。它被列入标准规范的草案中，后由于某些原因从web标准中被移除了。 但是，我们可以用以下两种定义进行抗锯齿渲染12-webkit-font-smoothing: antialiased; /*chrome、safari*/-moz-osx-font-smoothing: grayscale;/*firefox*/ （1）Webkit在自己的引擎中支持了这一效果。 -webkit-font-smoothing 它有三个属性值： none —— 对低像素的文本比较好 subpixel-antialiased——默认值 antialiased ——抗锯齿很好 例子：123body&#123; -webkit-font-smoothing: antialiased;&#125; 这个属性可以使页面上的字体抗锯齿,使用后字体看起来会更清晰。加上之后就顿时感觉页面小清晰了。 （2）Gecko也推出了自己的抗锯齿效果的非标定义。 -moz-osx-font-smoothing: inherit | grayscale; 这个属性也是更清晰的作用。 例子：1234.icon &#123; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; （3）Ionic框架在样式中多加了一条font-smoothing: antialiased; 这是坐等font-smoothing标准化，有备无患么。当然了还有一种方法了，使用Art-Reactor | 字体图标集 这里面有很多很多图标方便我们使用，使用方法也比较简单，详细看看这个就知道了http://chinakids.github.io/Art-Reactor/ 当然这个教程也不错 http://www.zcool.com.cn/article/ZMTc3NDg4.html123&lt;div class="arr"&gt; &lt;i class="arrow"&gt;&lt;/i&gt;&lt;/div&gt; 1234567891011121314151617.arr&#123; width:70px; height:70px; line-height:100px; background:rgba(153,153,153,0.8); border-radius:50%; text-align:center;&#125;.arr .arrow&#123; display: inline-block; width:26px; height:26px; border: solid #fff; border-width: 4px 4px 0 0; -webkit-transform:rotate(-45deg); transform:rotate(-45deg);&#125; 小应用：回到网站头部小图标]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于浮动与清除浮动]]></title>
      <url>%2F2016%2F04%2F29%2Fcss-float%2F</url>
      <content type="text"><![CDATA[页面布局方式，主要包含：文档流、浮动层、float属性。☞html页面的标准文档流(默认布局)是：从上到下，从左到右，遇块(块级元素)换行。 ☞浮动层：给元素的float属性赋值后，就是脱离文档流，进行左右浮动，紧贴着父元素(默认为body文本区域)的左右边框。而此浮动元素在文档流空出的位置，由后续的(非浮动)元素填充上去：块级元素直接填充上去，若跟浮动元素的范围发生重叠，浮动元素覆盖块级元素。内联元素：有空隙就插入。 ☞float属性包括left(元素向左浮动)、right(元素向右浮动)、 none(默认值)、(inherit)从父元素继承float属性。 但是浮动有时候会很烦，为什么说很烦呢？ 举个栗子吧 浮动对页面的影响：如果一个父盒子中有一个子盒子，并且父盒子没有设置高度，子盒子在父盒子中浮动，因为float会脱离文档流，这样就导致了父元素的height为0 ，下面的元素会自动补位。故需要进行清除浮动。 清楚浮动的方式有很多种，那就总结一下吧 1、使用额外标签法：在浮动盒子下面添加一个标签，使用clear:both来清楚浮动 这里我们发现很明显的缺点：父盒子还是不会直接显示，而且这种浮动方式会增加页面的标签，故一般情况下不采用这种清楚浮动方式 2、使用CSS的:after伪元素说明：给浮动元素的容器添加一个clearfix的class类，然后给这个class添加一个:after伪元素实现元素末尾添加一个空的块级元素（这个元素的高为0，行高也为0，并且这个元素清楚了浮动） 。为了IE6和IE7浏览器，要添加一条zoom:1;触发haslayout。 3、使用CSS的overflow属性先找到浮动盒子的父元素，再在父元素添加添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。注意：一般情况下也不使用这种清楚方式，因为overflow:hidden有一个属性，离开了这个元素所在的区域以后会被隐藏 综上所述：使用CSS的:after伪元素是最佳选择 关于浮动更多内容可以参考http://www.cnblogs.com/polk6/archive/2013/07/25/3142187.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css border制作小三角形状及气泡框(兼容IE6)]]></title>
      <url>%2F2016%2F03%2F29%2Fcss-triangle%2F</url>
      <content type="text"><![CDATA[先看下CSS盒模型 一个盒子包括: margin+border+padding+content上下左右边框交界处出呈现平滑的斜线.利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等.调整宽度大小可以调节三角形形状.一般情况下,我们设置盒子的宽高度, 及上下左右边框.12345678910111213141516&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; .test&#123; height:60px; width:60px; border-color:red green blue yellow; border-style:solid; border-width:30px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/body&gt; 根据盒子模型，我们把div宽高度都设为0时,12345678910111213141516&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; .test&#123; height:0px;/* div盒子设置高度设置为0 */ width:0px;/* div盒子设置宽度设置为0 */ border-color:red green blue yellow; border-style:solid; border-width:30px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/body&gt; 为了兼容IE6，需要添加代码 _font-size: 0; _line-height: 0;12345678910111213141516171819&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; .test&#123; height:0px;/* div盒子设置高度设置为0 */ width:0px;/* div盒子设置宽度设置为0 */ border-color:red green blue yellow; border-style:solid; border-width:30px; overflow: hidden; /* 这里设置overflow, font-size, line-height */ font-size: 0; /*是因为, 虽然宽高度为0, 但在IE6下会具有默认的 */ line-height: 0; /* 字体大小和行高, 导致盒子呈现被撑开的长矩形 */ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/body&gt; 这时, 其实我们已经看到有上下左右四个三角形了..如果, 我们把4种颜色, 只保留一种颜色, 余下3种颜色设置为透明(或者设置为和背景色相同的颜色), 那不就是一个小三角了么12345678910111213141516171819&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; .test&#123; height:0px;/* div盒子设置高度设置为0 */ width:0px;/* div盒子设置宽度设置为0 */ border-color:red transparent transparent transparent; border-style:solid; border-width:30px; overflow: hidden; /* 这里设置overflow, font-size, line-height */ font-size: 0; /*是因为, 虽然宽高度为0, 但在IE6下会具有默认的 */ line-height: 0; /* 字体大小和行高, 导致盒子呈现被撑开的长矩形 */ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/body&gt; 可是, IE6下不支持透明啊~~~, 会出现下图的样子（换句话说IE6不支持transparent，而使用默认的背景色黑色）为了解决这个兼容性问题，IE6下, 设置余下三条边的border-style为dashed，利用虚线样式的border可以形成天然无污染的空白，即可达到透明的效果。即把原来的代码中的 border-style:solid; 换成 border-style:solid dashed dashed dashed; 上面我们画的小三角的斜边都是依靠原来盒子的边, 还有另外一种形式的小三角, 就是斜边在盒子的对角线上123456789101112131415161718&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; .test&#123; height:0px;/* div盒子设置高度设置为0 */ width:0px;/* div盒子设置宽度设置为0 */ border-color:red green transparent transparent; border-style:solid solid dashed dashed; border-width:30px; overflow: hidden; /* 这里设置overflow, font-size, line-height */ font-size: 0; /*是因为, 虽然宽高度为0, 但在IE6下会具有默认的 */ line-height: 0; /* 字体大小和行高, 导致盒子呈现被撑开的长矩形 */ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/body&gt; 保留其中一种颜色, 就可以得到斜边在对角线上的三角形了…多个这样的三角形, 通过设置边框大小, 颜色, 拼凑起来可以形成任意形状的三角形.像这种不规则的三角形, 延伸一下, 放在气泡框上, 就可以省去拼背景图片的麻烦了.另外, 关于气泡框, 可以用特殊字符模拟小三角同样需要用到定位和重叠覆盖，只不过不需要调整border属性了。先来看一个菱形“◆” ，它在页面中的代码是“&amp;#9670”，需要注意的是页面编码需要设置为utf-8，在网页中可以把◆当作文字处理，可以通过调整font-size来它的大小、通过color来设置它的颜色。HTML结构依然用前面的，不同的是在em、span标签中加入了 ◆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt; /*先来设置最外层div的样式，得到一个矩形框*/ .tag&#123; width:300px; height:100px; position:relative; border:5px solid #09F; &#125; /*接着定位箭头最外层容器div，便于观察可以先设置一个背景色*/ .arrow&#123; position:absolute; width:40px; height:40px; left:100px; bottom:-40px; overflow:hidden; &#125; /*再对◆设置样式*/ .arrow *&#123; display:block; position:absolute; font-size:40px; line-height:40px; width:40px; font-family:SimSun; font-style:normal; font-weight:normal; text-align:center; vertical-align:middle; &#125; /*注意：为了◆主流浏览器中显示一致，需要清除浏览器的默认字体样式，特别注意这里字体的设置再分别修改em、span标签的字体颜色，并对这两个标签定位：*/ .arrow em&#123; color:#09F; top:-15px; &#125; .arrow span&#123; color:#FFF; top:-22px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tag"&gt; &lt;div class="arrow"&gt; &lt;em&gt;◆&lt;/em&gt; &lt;span&gt;◆&lt;/span&gt; &lt;/div&gt; CSS气泡框实现 &lt;/div&gt;&lt;/body&gt; 效果图为：补充：以上方式实现小三角的过程中不可避免的增加了多余的标签，如果不要求所有浏览器中显示一致的话， 我们可以利用css3来实现这个小三角123&lt;div class="tag"&gt; css3气泡框&lt;/div&gt; 123456789101112131415161718192021.tag&#123; width:300px; height:100px; border:5px solid #09F; position:relative; background-color:#FFF;&#125;.tag:before,.tag:after&#123; content:"";display:block; border-width:20px; position:absolute; bottom:-40px; left:100px; border-style:solid dashed dashed; border-color:#09F transparent transparent; font-size:0; line-height:0;&#125;.tag:after&#123; bottom:-33px; border-color:#FFF transparent transparent;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一名高效程序员应该有的7个习惯]]></title>
      <url>%2F2016%2F03%2F19%2Ftech-seven-habits%2F</url>
      <content type="text"><![CDATA[花的时间越多就能写出越可靠的代码吗？不一定。那如何才能写出优秀代码的呢？提示：懒惰是一个良好的开始哦。Perl 编程语言的原作者 Larry Wall 曾说过，伟大的程序员都有三个优点：懒惰、急躁和傲慢。为什么这样说呢？懒惰会促使他们去写一些省事儿的程序来辅助他们或别人更好的工作，这样他们就无需再去回答一些不想回答的问题。没耐心会激励他们去写一些程序，不等你提出就主动满足你的需求。傲慢会促使他们写出可靠无误的代码，因为他们不想受到批评和指责。但是，伟大的程序员也并不总是高效的，那些每天都能将自己的工作完成的很好的开发者，比那些偶尔编码到令人眩晕的高度的程序员要更高效。对大多数雇主来说，重要的是曲线下的面积，而不是最高点。 因此，为了最大限度得提高你的就业能力，你不需要成为一个伟大的开发者，而是一个高效的开发者。这里分享7个习惯，帮让你成为高效的开发者。 每天至少写4个小时代码 配合开发团队 利用业余时间编码 学会写潦草的代码 不要在相同的工作上停留过长时间 永远不要停止学习 因为热爱去编程 1.每天至少写4个小时代码乍一看，这条建议很没有意义，因为大部分程序员在他们的电脑桌前要写至少8个小时的代码，很多甚至是10个小时。然而，Copyin 的 创始人兼CEO Peter Nixey 认为，他们实际上只有很少的时间花在了实际开发工作中。“我曾经从事的项目中，开发者把他们的时间大部分都消磨在了会议、乒乓球、午餐等上面，”他说。“所以，纯粹写代码的时间是没有4个小时的，但令人惊讶的是，在办公环境中这点是很难实现的。”为什么呢？Nixey 解释说，一个很重要的因素就是，要保证开发者在那4个小时内不能被打扰。因为一旦你全身心投入进去，你的大脑就处在高速运行中，一旦中间被打断了，可能会需要你花一个小时的时间才能找回原来的感觉和思路。怪不得那么多程序员都不喜欢在编程中受到打扰呢。 2.配合开发团队作为团队中的其中一员，学会和你的同事相处是成为一个高效开发者的重要组成部分。开发者网络 Scalable Path CEO Damien Filiatrault 认为，这要比你有经验丰富的编码技能更重要。提出和一个自认为比别人聪明的家伙一起工作有多不开心。Filiatrault 说，无论他多么有才华，就问一个关键的问题，“和他们一起工作有趣吗？”如果答案是否定的，“那可能会影响整个团队的士气，”他补充到。但这不仅仅是自大的家伙单方面造成的问题。如果开发人员太好或者因为某些原因不适应团队环境也可能会出现一些问题。例如，Filiatrault指出，“世界上任何一个角落的开发者都想尽可能的避免冲突，而他们可能又不愿承认自己无能为力，这也是一个问题。” 3.利用业余时间编码如果你写代码仅仅是为了钱，那么你很难在新的领域学到新技能以及经验。这也是为什么 Added Bytes 的创始人Dave Child会说，为了娱乐而去编码是很重要的。他说：“我所知道的最好的开发者，他们业余都有自己研究的项目领域。”那些开发者不会为他们的小项目使用他们在工作中需要的技能，Child补充道。相反，他们会利用一些业余项目来增加自己的技能，同时让自己跟上新技术发展的步伐，这才是真正让他们兴奋的。 4.学会写潦草的代码很少有项目会需要开发者去天才般的创建华丽丽的代码作品：它们所需要的通常是一个可以在上面建立具体功能的通用平台。Nixey说最好的方式就是快速写一些可运行的作品，然后从中受益。“不管你的代码是邋遢也好，重复也好，命名很烂也好，”他说，“代码只是一种解决方案的表现形式，之后你可以去重构它，让它看起来很好。” 5.不要在相同的工作上停留过长时间Child说，一个保证不失去自己编程优势的有效方式就是去重新找一个工作，然后让自己融入到开发团队中。因为一旦你掌握了工作所需的所有技能，你就进入了一个死胡同，你的技能很难再提升，你也很难成为一个更好的程序员。“你需要不断挑战自己，”他说。“如果你在一个地方工作了好几年，那么你可能已经最大限度的学到了当时想学的东西，所以不要再待在那了——继续前行，去寻找新的挑战。” 6.永远不要停止学习软件技术更新的非常快，这意味着现在很多重要的编码技能可能很快就会过时。所以，如果你打算在软件开发领域有一个长期的发展，及时了解新的编程语言和技术趋势是非常重要的。开发公司Progress Software的首席布道官Todd Anglin说，“事实很简单但也很残酷，你现有的知识是不足以你去消费一辈子的，你必须做好不断去重新学习的准备，因为你现在所拥有的知识未来是不能满足你的需求的。”他还补充说，清楚并专注于你感兴趣的领域，而不是试图成为各行各业的高手是很重要的。“对你想深入学习的领域，要保持如饥似渴的态度和持续的激情。不要试图去啥都学，因为这是不可能的——要保持专注，不断学习。”Filiatrault也同意Todd的看法。“也许你每一份开发工作都会有一半之前没有做过的事情，所以你要有的重要的技能就是知道如何去学习，去寻找信息，”他说，“如果你有了这项技能，那么不管你需要什么你都可以通过自学拥有了。” 7.因为热爱去编程Gregor Riegler是Be a Better Developer博客的一个作者，他说，选择自己热爱的领域是至关重要的，这样才能确保自己能够全身心投入项目中去。“产生动力最重要的因素是你关心代码能够做什么，”他说，“也许它可以以某种方式让一个app运行，也许它会让一台机器以你希望的方式工作。”无论如何，他补充说，“你要真正去享受自己正在做的事，并尝试获得最佳效果。如果你能从中找到快乐，那么恭喜你，你一定会写出伟大的代码。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 隐藏页面元素的 几 种方法总结]]></title>
      <url>%2F2016%2F01%2F11%2Fcss-hidden%2F</url>
      <content type="text"><![CDATA[用 CSS 隐藏页面元素有许多种方法。你可以将 opacity 设为 0、将 visibility 设为 hidden、将 display 设为 none 或者将 position 设为 absolute 然后将位置设到不可见区域。 你有没有想过，为什么我们要有这么多技术来隐藏元素，而它们看起来都实现的是同样的效果？每一种方法实际上与其他方法之间都有一些细微的不同，这些不同决定了在一个特定的场合下使用哪一个方法。我们只需要记住的细小不同点，根据不同情况选择上面这些方法中适合的方法来隐藏元素。 displaydisplay 属性依照词义真正隐藏元素。将 display 属性设为 none 确保元素不可见并且连盒模型也不生成。使用这个属性，被隐藏的元素不占据任何空间。不仅如此，一旦display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在。 任何这个元素的子孙元素也会被同时隐藏。为这个属性添加过渡动画是无效的，它的任何不同状态值之间的切换总是会立即生效。 不过请注意，通过 DOM 依然可以访问到这个元素。因此你可以通过 DOM 来操作它，就像操作其他的元素。 123.hide &#123; display: none;&#125; 看下面的例子： @SitePoint 提供的例子“用 display 隐藏元素” 你将看到第二个块元素内有一个 &lt;p&gt; 元素，它自己的 display 属性被设置成block，但是它依然不可见。这是 visibility:hidden 和 display:none 的另一个不同之处。在前一个例子里，将任何子孙元素 visibility 显式设置成 visible 可以让它变得可见，但是 display 不吃这一套，不管自身的 display 值是什么，只要祖先元素的 display 是 none，它们就都不可见。 现在，将鼠标移到第一个块元素上面几次，然后点击它。这个操作将让第二个块元素显现出来，它其中的数字将是一个大于 0 的数。这是因为，元素即使被这样设置成对用户隐藏，还是可以通过 JavaScript 来进行操作。 Visibility第二个要说的属性是 visibility。将它的值设为 hidden 将隐藏我们的元素。如同opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏。 这个属性也能够实现动画效果，只要它的初始和结束状态不一样。这确保了 visibility 状态切换之间的过渡动画可以是时间平滑的（事实上可以用这一点来用 hidden 实现元素的延迟显示和隐藏——译者注）。 123.hide &#123; visibility: hidden;&#125; 下面的例子演示了 visibility 与 opacity 有怎样的不同： 看 @SitePoint 提供的例子“用 visibility 隐藏元素” 注意，如果一个元素的 visibility 被设置为 hidden，同时想要显示它的某个子孙元素，只要将那个元素的 visibility 显式设置为 visible 即可（就如例子里面的 .o-hide p——译者注）。尝试只 hover 在隐藏元素上，不要 hover 在 p 标签里的数字上，你会发现你的鼠标光标没有变成手指头的样子。此时，你点击鼠标，你的 click 事件也不会被触发。 而在 &lt;div&gt; 标签里面的 &lt;p&gt; 标签则依然可以捕获所有的鼠标事件。一旦你的鼠标移动到文字上，&lt;div&gt; 本身变得可见并且事件注册也随之生效。 Opacityopacity 属性的意思是设置一个元素的透明度。它不是为改变元素的边界框（bounding box）而设计的。这意味着将 opacity 设为 0 只能从视觉上隐藏元素。而元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互。 123.hide &#123; opacity: 0;&#125; 如果你打算使用 opacity 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。 我还要提醒一句，opacity 属性可以用来实现一些效果很棒的动画。任何 opacity 属性值小于 1 的元素也会创建一个新的堆叠上下文（stacking context）。 看下面的例子： 看 @SitePoint 提供的例子“用 opacity 隐藏元素” 当你的鼠标移到被隐藏的第 2 个的区块上，元素状态平滑地从完全透明过渡到完全不透明。区块也将 cursor 属性设置为了 pointer，这说明了用户可以与它交互。 Position假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。下面是采用这种办法的 CSS： 12345.hide &#123; position: absolute; top: -9999px; left: -9999px;&#125; 下面的例子阐明了怎样通过绝对定位的方式隐藏元素，并让它和前面的那个例子效果一样： 看 @SitePoint 提供的例子“用 position 属性隐藏元素” 这种方法的主要原理是通过将元素的 top 和 left 设置成足够大的负数，使它在屏幕上不可见。采用这个技术的一个好处（或者潜在的缺点）是用它隐藏的元素的内容可以被读屏软件读取。这完全可以理解，是因为你只是将元素移到可视区域外面让用户无法看到它。 你得避免使用这个方法去隐藏任何可以获得焦点的元素，因为如果那么做，当用户让那个元素获得焦点时，会导致一个不可预料的焦点切换。这个方法在创建自定义复选框和单选按钮时经常被使用。（用 DOM 模拟复选框和单选按钮，但用这个方法隐藏真正的 checkbox 和 radio 元素来“接收”焦点切换——译者注） Clip-path隐藏元素的另一种方法是通过剪裁它们来实现。在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了，换成一个更好的属性叫做 clip-path。Nitish Kumar 最近在 SitePoint 发表了“介绍 clicp-path 属性”这篇文章，通过阅读它可以了解这个属性的更多高级用法。 记住，clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要更低。使用 clip-path 属性来隐藏元素的代码看起来如下： 123.hide &#123; clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);&#125; 下面是一个实际使用它的例子： 看 @SitePoint 提供的例子“用 clip-path 属性隐藏元素” 如果你把鼠标悬停在第一个元素上，它依然可以影响第二个元素，尽管第二个元素已经通过clip-path 隐藏了。如果你点击它，它会移除用来隐藏的 class，让我们的元素从那个位置显现出来。被隐藏元素中的文字仍然能够通过读屏软件读取，许多 WordPress 站点使用clip-path 或者之前的 clip 来实现专门为读屏软件提供的文字。 虽然我们的元素自身不再显示，它也依然占据本该占据的矩形大小，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。在我们的例子里，剪裁区大小为零，这意味着用户将不能与隐藏的元素直接交互。此外，这个属性能够使用各种过渡动画来实现不同的效果。 结论在这篇教程里，我们看了 5 种不同的通过 CSS 隐藏元素的方法。每一种方法都与其他几种有一点区别。知道你想要实现什么有助于你决定采用哪一个属性，随着时间推移，你就能根据实际需求本能地选择最佳方式了。 转自：http://www.zcfy.cc/article/457]]></content>
    </entry>

    
  
  
</search>
